// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

package com.aeolid.generatorproofing;

import com.intellij.codeInspection.AbstractBaseJavaLocalInspectionTool;
import com.intellij.codeInspection.ProblemDescriptorBase;
import com.intellij.codeInspection.ProblemHighlightType;
import com.intellij.codeInspection.ProblemsHolder;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.TextRange;
import com.intellij.openapi.util.text.StringUtilRt;
import com.intellij.openapi.vcs.VcsException;
import com.intellij.openapi.vcs.changes.Change;
import com.intellij.openapi.vcs.changes.ChangeListManager;
import com.intellij.openapi.vcs.changes.ContentRevision;
import com.intellij.openapi.vcs.ex.Range;
import com.intellij.openapi.vcs.ex.RangesBuilder;
import com.intellij.psi.*;
import com.intellij.util.containers.ContainerUtil;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Implements an inspection to detect when String references are compared using 'a==b' or 'a!=b'.
 * The quick fix converts these comparisons to 'a.equals(b) or '!a.equals(b)' respectively.
 */
public class InspectionImpl extends AbstractBaseJavaLocalInspectionTool {

	private static final String PATTERNAFFECTEDFILE = " * File generated by the template based ISKV code generator";
	private static final String PATTERNSTART = "// USER SECTION BEGIN";
	private static final String PATTERNEND = "// USER SECTION END";

	private static final String ERRORTEXT = InspectionBundle.message("inspection.generatedCodePattern.display.name");


	private static class GeneratorPatternVisitor extends JavaElementVisitor {
		private final ProblemsHolder holder;
		private final boolean isOnTheFly;
		private final boolean isAffectedFile;
		private final List<TextRange> affectedRanges;


		public GeneratorPatternVisitor(ProblemsHolder holder, boolean isOnTheFly) {
			this.holder = holder;
			this.isOnTheFly = isOnTheFly;

			PsiFile file = holder.getFile();
			isAffectedFile = file.getFirstChild().getText().contains(PATTERNAFFECTEDFILE);

			if (isAffectedFile) {
				Project project = file.getProject();
				Change change = ChangeListManager.getInstance(project).getChange(file.getVirtualFile());
				String contentFromVcs = change != null ? getRevisionedContentFrom(change) : null;
				Document document = PsiDocumentManager.getInstance(project).getDocument(file);
				List<Range> gotRanges = document != null && contentFromVcs != null ? getRanges(document, contentFromVcs) : null;
				List<TextRange> changedRanged = getChangedRanges(gotRanges, change, file, document, contentFromVcs);

				affectedRanges = changedRanged == null ? Collections.emptyList() : changedRanged;
			} else {
				affectedRanges = Collections.emptyList();
			}
		}

		private static List<TextRange> getChangedRanges(List<? extends Range> gotRanges, Change change, PsiFile file, Document document, String contentFromVcs) {
			if (change != null && change.getType() == Change.Type.NEW) {
				TextRange fileRange = file.getTextRange();
				return ContainerUtil.newArrayList(fileRange);
			}

			return contentFromVcs != null ? calculateChangedRangesInfo(gotRanges, document) : null;
		}

		private static List<TextRange> calculateChangedRangesInfo(List<? extends Range> gotRanges, @NotNull Document document) {
			return getChangedTextRanges(document, gotRanges);
		}

		private static List<TextRange> getChangedTextRanges(@NotNull Document document, @NotNull List<? extends Range> changedRanges) {
			final List<TextRange> ranges = new ArrayList<>();

			for (Range range : changedRanges) {
				if (range.hasLines()) {
					int changeStartLine = range.getLine1();
					int changeEndLine = range.getLine2();

					int lineStartOffset = document.getLineStartOffset(changeStartLine);
					int lineEndOffset = document.getLineEndOffset(changeEndLine - 1);

					TextRange changedTextRange = new TextRange(lineStartOffset, lineEndOffset);
					ranges.add(changedTextRange);
				} else if (range.hasVcsLines()) {
					int lineEndOffset = document.getLineStartOffset(range.getVcsLine1());
					TextRange changedTextRange = new TextRange(lineEndOffset, lineEndOffset);
					ranges.add(changedTextRange);
				}
			}

			return ranges;
		}

		private static String getRevisionedContentFrom(@NotNull Change change) {
			ContentRevision revision = change.getBeforeRevision();
			if (revision == null) {
				return null;
			}

			try {
				return revision.getContent();
			}
			catch (VcsException e) {
				return null;
			}
		}

		@NotNull
		private static List<Range> getRanges(@NotNull Document document,
			@NotNull CharSequence contentFromVcs) {
			return RangesBuilder.createRanges(document.getImmutableCharSequence(), StringUtilRt.convertLineSeparators(contentFromVcs, "\n"));
		}

		private boolean isInsideSection;
		private final List<List<PsiElement>> psiRanges = new ArrayList<>();

		@Override
		public void visitComment(@NotNull PsiComment comment) {
			if (isAffectedFile && comment.getText().contains(PATTERNEND)) {
				isInsideSection = false;
			}

			super.visitComment(comment);

			if (isAffectedFile && comment.getText().contains(PATTERNSTART)) {
				isInsideSection = true;
			}
		}

		private static final List<Class<? extends PsiElement>> blacklistedClasses = Arrays.asList(
			PsiJavaCodeReferenceElement.class,
			PsiCodeBlock.class,
			PsiReferenceParameterList.class,
			PsiErrorElement.class,
			PsiMethodCallExpression.class,
			PsiMethod.class,
			PsiClass.class,
			PsiPackageStatement.class,
			PsiJavaFile.class
		);

		private static boolean isBlacklistedInstance(PsiElement element) {
			for (Class<? extends PsiElement> blacklistedClass : blacklistedClasses) {
				if (blacklistedClass.isInstance(element)) return true;
			}
			return false;
		}

		@Override
		public void visitElement(@NotNull PsiElement element) {
			if (isAffectedFile) {
				if (!isInsideSection && !isBlacklistedInstance(element)) {
					checkRange(element);
					if (element instanceof PsiWhiteSpace) {
						PsiElement nextSibling = element.getNextSibling();
						if (nextSibling != null &&  !isBlacklistedInstance(nextSibling)) {
							checkRange(nextSibling);
						}
					}
				} else if (element instanceof PsiJavaFile) {
				outputAffectedRanges();
					System.out.println(psiRanges.size());
					System.out.println("----");
				}
			}
			super.visitElement(element);
		}

		private static List<PsiElement> newBasePair(PsiElement element) {
			List<PsiElement> basePair = new ArrayList<>();
			basePair.add(element);
			basePair.add(element);
			return basePair;
		}

		private void checkRange(@NotNull PsiElement element) {
			TextRange textRange = element.getTextRange();
			for (TextRange changedRange : affectedRanges) {
				if (
					changedRange.contains(textRange.getStartOffset()) ||
					changedRange.contains(textRange.getEndOffset() - 1) ||
					textRange.contains(changedRange)
				) {
					System.out.println(textRange + ": " + element.getClass());

					if (psiRanges.isEmpty()) {
						psiRanges.add(newBasePair(element));
					}

					List<PsiElement> lastPsiRange = psiRanges.get(psiRanges.size() - 1);
					int lastOffset = lastPsiRange.get(1).getTextRange().getEndOffset();
					if (lastOffset >= textRange.getStartOffset() && lastOffset < textRange.getEndOffset()) {
						lastPsiRange.set(1, element);
					} else if (lastOffset < textRange.getStartOffset()) {
						psiRanges.add(newBasePair(element));
					}
				}
			}
		}

		private void outputAffectedRanges() {
			for (List<PsiElement> psiElements : psiRanges) {
				holder.registerProblem(
					new ProblemDescriptorBase(
						psiElements.get(0),
						psiElements.get(1),
						ERRORTEXT,
						null,
						ProblemHighlightType.ERROR,
						false,
						null,
						true,
						isOnTheFly
					)
				);
			}
		}
	}

	@NotNull
	@Override
	public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {
		return new GeneratorPatternVisitor(holder, isOnTheFly);
	}
}
