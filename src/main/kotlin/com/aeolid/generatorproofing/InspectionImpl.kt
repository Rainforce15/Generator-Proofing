package com.aeolid.generatorproofing

import com.aeolid.generatorproofing.InspectionBundle.getMessage
import com.intellij.codeInspection.*
import com.intellij.codeInspection.ProblemHighlightType.ERROR
import com.intellij.codeInspection.options.*
import com.intellij.openapi.project.Project
import com.intellij.openapi.util.TextRange
import com.intellij.openapi.util.text.HtmlChunk
import com.intellij.psi.*

class InspectionImpl: AbstractBaseJavaLocalInspectionTool() {
	private val inspectionName = getMessage("inspection.generatedCodePattern.name")

	private val patternHeaderLabel = getMessage("inspection.generatedCodePattern.patternHeader")

	private val headerPatternLabel = getMessage("inspection.generatedCodePattern.headerPattern")
	private val headerPatternInfo = HtmlChunk.raw(getMessage("inspection.generatedCodePattern.headerPatternInfo"))
	private val beginPatternLabel = getMessage("inspection.generatedCodePattern.beginPattern")
	private val beginPatternInfo = HtmlChunk.raw(getMessage("inspection.generatedCodePattern.beginPatternInfo"))
	private val endPatternLabel = getMessage("inspection.generatedCodePattern.endPattern")
	private val endPatternInfo = HtmlChunk.raw(getMessage("inspection.generatedCodePattern.endPatternInfo"))
	private val tsPatternLabel = getMessage("inspection.generatedCodePattern.tsPattern")
	private val tsPatternInfo = HtmlChunk.raw(getMessage("inspection.generatedCodePattern.tsPatternInfo"))

	private val jaxbHeader = getMessage("inspection.generatedCodePattern.jaxbHeader")

	private val checkJaxbLabel = getMessage("inspection.generatedCodePattern.checkJaxb")
	private val checkJaxbInfo = HtmlChunk.raw(getMessage("inspection.generatedCodePattern.checkJaxbInfo"))

	private val ignoreFileLabel = getMessage("inspection.generatedCodePattern.ignoreFile")
	private val ignoreFolderLabel = getMessage("inspection.generatedCodePattern.ignoreFolder")
	private val ignoreForNow = getMessage("inspection.generatedCodePattern.ignoreForNow")

	val ignoredFiles = HashSet<String>()
	val ignoredFolders = HashMap<String, HashSet<String>>()

	var headerPattern = ""
	var beginPattern = ""
	var endPattern = ""
	var tsPattern = ""
	var checkJaxb = false

	private val jaxbPattern = "// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation"

	override fun runForWholeFile() = true

	override fun getOptionsPane() = OptPane.pane(
		OptGroup(PlainMessage(patternHeaderLabel), listOf(
			OptString("headerPattern", PlainMessage(headerPatternLabel),null, -1, headerPatternInfo),
			OptString("beginPattern", PlainMessage(beginPatternLabel),null, -1, beginPatternInfo),
			OptString("endPattern", PlainMessage(endPatternLabel),null, -1, endPatternInfo),
			OptString("tsPattern", PlainMessage(tsPatternLabel),null, -1, tsPatternInfo)
		)),
		OptGroup(PlainMessage(jaxbHeader), listOf(
			OptCheckbox("checkJaxb", PlainMessage(checkJaxbLabel), emptyList(), checkJaxbInfo)
		))
	)

	private fun getQuickFixes(file: PsiJavaFile): Array<LocalQuickFix> {
		val smartFile = SmartPointerManager.getInstance(file.project).createSmartPsiElementPointer(file)
		return arrayOf(
			object: LocalQuickFix {
				override fun getName(): String = ignoreFileLabel
				override fun getFamilyName() = ignoreForNow
				override fun applyFix(p: Project, d: ProblemDescriptor) {
					ignoredFiles.add(smartFile.virtualFile.path)
				}
			},
			object: LocalQuickFix {
				override fun getName(): String = ignoreFolderLabel
				override fun getFamilyName() = ignoreForNow
				override fun applyFix(p: Project, d: ProblemDescriptor) {
					ignoredFolders.getOrPut(smartFile.virtualFile.parent.path) { HashSet() }.add(smartFile.virtualFile.path)
				}
			}
		)
	}

	private fun commentContainsText(psiElement: PsiElement, text: String) =
		psiElement is PsiComment && psiElement.text.contains(text)

	private fun checkFileForConfiguredPattern(holder: ProblemsHolder, file: PsiJavaFile) {
		if (headerPattern.isNotBlank() && beginPattern.isNotBlank() && endPattern.isNotBlank()) {
			val firstChild = file.firstChild

			if (firstChild is PsiComment && commentContainsText(firstChild, headerPattern)) {
				val affectedRanges = getAffectedRanges(file, beginPattern, endPattern)
				if (isFileNotRecentlyGenerated(firstChild, affectedRanges)) {
					checkFileForRanges(holder, file, affectedRanges)
				}
			}
		}
	}

	private fun isFileNotRecentlyGenerated(firstChild: PsiComment, affectedRanges: List<TextRange>): Boolean {
		val tsMatch = Regex(tsPattern).find(firstChild.text)
		if (tsMatch != null) {
			val tsRange = tsMatch.range
			for (range in affectedRanges) {
				if (range.intersects(tsRange.first, tsRange.last)) {
					return false
				}
			}
		}
		return true
	}

	private fun checkFileForJaxb(holder: ProblemsHolder, file: PsiJavaFile) {
		if (checkJaxb) {
			val children = file.children

			if (commentContainsText(children[0], jaxbPattern) || children.size > 1 && commentContainsText(children[2], jaxbPattern)) {
				val affectedRanges = getAffectedRanges(file, "", "")
				checkFileForRanges(holder, file, affectedRanges)
			}
		}
	}

	private fun fixIgnored(file: PsiJavaFile, fileHasChanges: Boolean) {
		val vFile = file.virtualFile.path
		val vParent = file.virtualFile.parent.path

		if (!fileHasChanges) {
			ignoredFiles.remove(vFile)
			ignoredFolders[vParent]?.remove(vFile)
			if(ignoredFolders[vParent]?.isEmpty() == true) {
				ignoredFolders.remove(vParent)
			}
		} else if (ignoredFolders.contains(vParent)) {
			ignoredFolders[vParent]?.add(vFile)
		}
	}

	private fun isIgnored(file: PsiJavaFile) =
		ignoredFiles.contains(file.virtualFile.path) || ignoredFolders.keys.any { file.virtualFile.parent.path.startsWith(it) }

	private fun checkFileForRanges(holder: ProblemsHolder, file: PsiJavaFile, affectedRanges: List<TextRange>) {
		fixIgnored(file, affectedRanges.isNotEmpty())

		if(!isIgnored(file)) {
			for (changedRange in affectedRanges) {
				holder.registerProblem(ProblemDescriptorBase(
					file, file, inspectionName, getQuickFixes(file), ERROR, false, changedRange, true, false
				))
			}
		}
	}

	override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean) = object: JavaElementVisitor() {
		override fun visitJavaFile(file: PsiJavaFile) {
			checkFileForConfiguredPattern(holder, file)
			checkFileForJaxb(holder, file)

			super.visitJavaFile(file)
		}
	}
}
