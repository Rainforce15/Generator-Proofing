package com.aeolid.generatorproofing

import com.aeolid.generatorproofing.InspectionBundle.getMessage
import com.intellij.codeInspection.*
import com.intellij.codeInspection.ProblemHighlightType.ERROR
import com.intellij.codeInspection.options.*
import com.intellij.openapi.project.Project
import com.intellij.openapi.util.TextRange
import com.intellij.openapi.util.text.HtmlChunk
import com.intellij.psi.*
import org.intellij.lang.annotations.Language

class InspectionImpl: AbstractBaseJavaLocalInspectionTool() {

	val ignoredFiles = HashSet<String>()

	var headerPattern = ""
	var beginPattern = ""
	var endPattern = ""
	var checkJaxb = false

	private val jaxbPattern = "// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation"

	override fun runForWholeFile() = true

	private fun getOptString(@Language("jvm-field-name") bindId: String, labelId: String, infoTextId: String) =
		OptString(bindId, PlainMessage(getMessage(labelId)), null, -1, HtmlChunk.raw(getMessage(infoTextId)))

	private fun getOptCheckbox(@Language("jvm-field-name") bindId: String, labelId: String, infoTextId: String) =
		OptCheckbox(bindId, PlainMessage(getMessage(labelId)), emptyList(), HtmlChunk.raw(getMessage(infoTextId)))

	override fun getOptionsPane() = OptPane.pane(
		getOptString("headerPattern", "inspection.generatedCodePattern.headerPattern", "inspection.generatedCodePattern.headerPatternInfo"),
		getOptString("beginPattern", "inspection.generatedCodePattern.beginPattern", "inspection.generatedCodePattern.beginPatternInfo"),
		getOptString("endPattern", "inspection.generatedCodePattern.endPattern", "inspection.generatedCodePattern.endPatternInfo"),
		getOptCheckbox("checkJaxb", "inspection.generatedCodePattern.checkJaxb", "inspection.generatedCodePattern.checkJaxbInfo")
	)

	private fun getQuickFixes(file: PsiJavaFile) = arrayOf(
		object: LocalQuickFix {
			override fun getName(): String = getMessage("inspection.generatedCodePattern.ignoreFile")
			override fun getFamilyName() = getMessage("inspection.generatedCodePattern.ignoreForNow")
			override fun applyFix(p: Project, d: ProblemDescriptor) { ignoredFiles.add(file.virtualFile.path) }
		}
	)

	private fun commentContainsText(psiElement: PsiElement, text: String) =
		psiElement is PsiComment && psiElement.text.contains(text)

	private fun checkFileForConfiguredPattern(holder: ProblemsHolder, file: PsiJavaFile) {
		if (headerPattern.isNotBlank() && beginPattern.isNotBlank() && endPattern.isNotBlank()) {
			val firstChild = file.firstChild

			if (commentContainsText(firstChild, headerPattern)) {
				val affectedRanges = getAffectedRanges(file, beginPattern, endPattern)
				checkFileForRanges(holder, file, affectedRanges)
			}
		}
	}

	private fun checkFileForJaxb(holder: ProblemsHolder, file: PsiJavaFile) {
		if (checkJaxb) {
			val firstChild = file.children[0]
			val secondChild = file.children[2]

			if (commentContainsText(firstChild, jaxbPattern) || commentContainsText(secondChild, jaxbPattern)) {
				val affectedRanges = getAffectedRanges(file, null, null)
				checkFileForRanges(holder, file, affectedRanges)
			}
		}
	}

	private fun fixIgnored(file: PsiJavaFile, fileHasChanges: Boolean) {
		val vFile = file.virtualFile.path

		if (!fileHasChanges) {
			ignoredFiles.remove(vFile)
		}
	}

	private fun isIgnored(file: PsiJavaFile) = ignoredFiles.contains(file.virtualFile.path)

	private fun checkFileForRanges(holder: ProblemsHolder, file: PsiJavaFile, affectedRanges: List<TextRange>) {
		fixIgnored(file, affectedRanges.isNotEmpty())

		if(!isIgnored(file)) {
			for (changedRange in affectedRanges) {
				holder.registerProblem(
					ProblemDescriptorBase(
						file,
						file,
						getMessage("inspection.generatedCodePattern.name"),
						getQuickFixes(file),
						ERROR,
						false,
						changedRange,
						true,
						false
					)
				)
			}
		}
	}

	override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean) = object: JavaElementVisitor() {
		override fun visitJavaFile(file: PsiJavaFile) {
			checkFileForConfiguredPattern(holder, file)
			checkFileForJaxb(holder, file)

			super.visitJavaFile(file)
		}
	}
}
